<!DOCTYPE html>
<html>
<head>
	<title>Spelz.io</title>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
        }
        #mycanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
	</style>
</head>
<body>
	<canvas id="mycanvas"></canvas>
	<script type="text/javascript" src="js/storageManager.js"></script>
	<script type="text/javascript" src="js/globalUtilities.js"></script>
	<script type="text/javascript" src="js/mob.js"></script>
	<script type="text/javascript" src="js/playableCharacter.js"></script>
	<script type="text/javascript" src="js/spellBook.js"></script>
	<script type="text/javascript" src="js/spell.js"></script>
	<script type="text/javascript" src="js/button.js"></script>
	<script type="text/javascript" src="js/text.js"></script>
	<script type="text/javascript" src="js/background.js"></script>
	<script type="text/javascript" src="js/camera.js"></script>
	<script type="text/javascript" src="js/libraries/spellBookLibrary.js"></script>
	<script type="text/javascript" src="js/libraries/lootDropLibrary.js"></script>
	<script type="text/javascript" src="js/loot.js"></script>
	<script type="text/javascript" src="js/libraries/mobLibrary.js"></script>

	<script>
		/*
		reminders when working on this game:
		1. always commit all and push to github before coding something new or big.
		2. when adding new code that is referenced or initialized on a different file,
		   comment it out so that future debugging will be easier to execute.


		other possibly useless reminder:
		1. performace.now() can reach billions of numbers.
		   if this increases too much, it can cause lag to the game.
		   add a way to reset it overtime.
		*/
		const starterMobsArray = [
			luminousRock,
			luminousSpirit,
			specter,
			gloomForestTree,
			gloomForestTreant,
			gloomForestSpecterTreant,
			luminousSpiritTreant,
			wanderingFog,
			zapper];

		document.addEventListener("DOMContentLoaded", function () {
			myGame.start();
			resizeCanvas();
		});

		function mainMenu() {

		}

        function startGame() {
            // Reset game state
            buttonsMap.clear();
            textsMap.clear();
            spellBooksArray = [];
            spellsArray = [];
            mobsArray = [];
            lootsArray = [];
            inventoryArray = [];

            buttonsKeeper();
            setUpSpellBooks();
            setUpInventory();

            // Safety checks
            if (!savedData.name || savedData.name.trim() === "") {
                savedData.name = "unnamed player";
                StorageManager.save("savedPlayerData", savedData);
            }

            // Create background
            biome1 = new Background(0, 0, 10000, 10000, "grayBG.png");

            // Initialize player with saved data (cleaner and direct)
            myGameCharacter = new PlayableCharacter(
                5000,
                5000,
                5000,
                5000,
                5000,
                5000,
                "mob/player.svg",
                false,
                false,
                savedData.maxHealth,
                0.5,
                1,
                20,
                0,
                savedData.name,
                savedData.maxMana,
                savedData.experience,
                savedData.level,
                "alive"
            );

            camera = new Camera(canvas.width, canvas.height);
            shake = new ScreenShake();
            spawnMobs();

            if (savedData.isFirstTimePlaying) {
                spellBooksKeeper();
                savedData.isFirstTimePlaying = false;
				StorageManager.save("savedPlayerData", savedData);
            }

            const mainMenuVariable = document.getElementById("mainMenu");
            if (mainMenuVariable) mainMenuVariable.remove();

			
			// delete this later (debug)
			/*
            addLootToInventory(specterHandPage, 64);
			addLootToInventory(gloomEssence, 64);
            addLootToInventory(gloomEssence, 64);
			*/
			
			//addLootToInventory(spikePage, 60);
            //addLootToInventory(gloomEssence, 60);
			//addLootToInventory(gloomEssence, 60);
            //addLootToInventory(gloomEssence, 60);
            //addLootToInventory(gloomEssence, 60);
			
        }

		function buttonsKeeper() {
			// stats bar
			addButton(buttonLibrary.levelBar, 0);
			addButton(buttonLibrary.experienceBar, 1);
			addButton(buttonLibrary.healthBar, 2);
			addButton(buttonLibrary.manaBar, 3);
			// clickable buttons
			addButton(buttonLibrary.inventoryButton, null);
			addButton(buttonLibrary.settingsButton, null);
			addButton(buttonLibrary.exitButton, null);

			addButton(buttonLibrary.spellBookSlot1, 1);
			addButton(buttonLibrary.spellBookSlot2, 2);
			addButton(buttonLibrary.spellBookSlot3, 3);
			addButton(buttonLibrary.spellBookSlot4, 4);
			console.log(savedData.spellBookSlotsUnlocked, savedData.level);
            if (savedData.level >= 5) {
                addButton(buttonLibrary.spellBookSlot5, 5);
                // add extra spellBookSlot
            }
            if (savedData.level >= 15) {
                addButton(buttonLibrary.spellBookSlot6, 6);
                // add extra spellBookSlot
            }
            if (savedData.level >= 30) {
                addButton(buttonLibrary.spellBookSlot7, 7);
                // add extra spellBookSlot
            }
            if (savedData.level >= 45) {
                addButton(buttonLibrary.spellBookSlot8, 8);
                // add extra spellBookSlot
            }
            if (savedData.level >= 60) {
                addButton(buttonLibrary.spellBookSlot9, 9);
                // add extra spellBookSlot
            }
		}

		function spellBooksKeeper() {
			//below this comment is the primary spell
			addSpellBook(spellBookLibrary.spikeBook, 1);
            //addSpellBook(spellBookLibrary.beamBook, 2);
			
			/*
			addSpellBook(spellBookLibrary.lightningBoltBook, 1);
			addSpellBook(spellBookLibrary.smashBook, 2);
			addSpellBook(spellBookLibrary.specterBook, 3);
			addSpellBook(spellBookLibrary.luminousShieldBook, 4);
			*/

			/*
			addSpellBook(spellBookLibrary.lightningBoltBook, 1);
			addSpellBook(spellBookLibrary.lightningBoltBook, 2);
			addSpellBook(spellBookLibrary.lightningBoltBook, 3);
			addSpellBook(spellBookLibrary.lightningBoltBook, 4);
			*/

			/*
			addSpellBook(spellBookLibrary.energyBallBook, null);
			addSpellBook(spellBookLibrary.specterBook, null);
			addSpellBook(spellBookLibrary.teleportBook, null);
			addSpellBook(spellBookLibrary.luminousEnergyBook, null);
			addSpellBook(spellBookLibrary.spikeBook, null);
			addSpellBook(spellBookLibrary.specterHandBook, null);
			addSpellBook(spellBookLibrary.treeBook, null);
			*/
		}

		function updateCanvas(time) {
			gameTime = time;

			if (resizePending) {
				resizeCanvas();
				resizePending = false;
			}

			ctx.clearRect(0, 0, myGame.canvas.width, myGame.canvas.height);
			ctx.fillStyle = "gray";
			ctx.fillRect(0, 0, myGame.canvas.width, myGame.canvas.height);

			if (startMenuScreen) {
				if (!startMenuButtons) {
					startMenuButtons = true;
					buttonsMap.clear();
					textsMap.clear();
					addText(textLibrary.gameTitle);
					addButton(buttonLibrary.playButton, null);
					addButton(buttonLibrary.nameInput, null);
				}

				const nameInputButton = buttonsMap.get("nameInput");
                // If the player is editing their name
                if (nameInputButton.toggle) {
                    if (lastKeyPressed && typeof lastKeyPressed === 'string') {
                        if (keyPressedOnce['Backspace']) {
                            nameInputButton.text = nameInputButton.text.slice(0, -1);
                        }
                        if (
                            (keyPressedOnce[`Key${lastKeyPressed.toUpperCase()}`] ||
                                keyPressedOnce[`Digit${lastKeyPressed}`] ||
                                keyPressedOnce['Space']) &&
                            /^[a-zA-Z0-9 ]$/.test(lastKeyPressed)
                        ) {
                            nameInputButton.text += lastKeyPressed;
                        }
                    }
                } else {
                    // Not editing â€” show the saved name
                    nameInputButton.text = savedData.name;
                }

                // Save name automatically when player finishes editing
				if (!nameInputButton.toggle && nameInputButton.text.trim() !== savedData.name.trim()) {
                    if (!nameInputButton.text.trim()) {
                        nameInputButton.text = "unnamed player";
                    }
                    savedData.name = nameInputButton.text.trim();
                    StorageManager.save("savedPlayerData", savedData);
				}

				// enter the game via enter button
				if (keyPressedOnce['Enter']) {
					setUpPlayerName();
					gameplayScreen = true;
				}

				for (const code in keyPressedOnce) {
					keyPressedOnce[code] = false;
				}
			}

			if (gameplayScreen) {
				if (!gameStarted) {
					startGame();
					gameStarted = true;
					startMenuScreen = false;
				}
				updateGameplayScreen();
			}
			//console.log(buttonsMap);

			buttonsMap.forEach(button => {
				if (button.isShaking) {
					button.updateShake(performance.now());
				}
			});
			// Step 1: Get all buttons as an array
			const buttonsArray = Array.from(buttonsMap.values());

			// Step 2: Sort by zIndex (lowest to highest)
			buttonsArray.sort((a, b) => a.zIndex - b.zIndex);

			// Step 3: Draw each button in order
			for (const button of buttonsArray) {
				button.draw(ctx);
			}

            spellBooksArray.forEach(spellBook => {
                spellBook.update();
			});

			// texts
			const textsArray = Array.from(textsMap.values());

			textsArray.sort((a, b) => a.zIndex - b.zIndex);

			for (const text of textsArray) {
				text.draw(ctx);
			}

			requestAnimationFrame(updateCanvas);
		}

		function resizeCanvas() {
			const canvas = myGame.canvas;
			newWidth = window.innerWidth;
			newHeight = window.innerHeight;
			dpr = window.devicePixelRatio || 1;

			if (canvas.width !== newWidth * dpr || canvas.height !== newHeight * dpr) {
				canvas.width = newWidth * dpr;
				canvas.height = newHeight * dpr;
				canvas.style.width = newWidth + "px";
				canvas.style.height = newHeight + "px";
			}

			myGame.context.setTransform(1, 0, 0, 1, 0, 0);
			myGame.context.scale(dpr, dpr);

			baseSize = ((screen.width + screen.height) * 0.2) + ((window.innerWidth + window.innerHeight) * 0.8);
			lootSize = baseSize * 0.025;
			slotSize = baseSize * 0.03;
			slotMargin = baseSize * 0.005;
			radiiSize = baseSize * 0.002;
			miniButtonSize = baseSize * 0.015;
			buttonMargin = baseSize * 0.005;
			lineThickness = baseSize * 0.0008;
			fontSize = baseSize * 0.00575;

			centerX = window.innerWidth / 2;
			centerY = window.innerHeight / 2;
			statsBarX = window.innerWidth * 0.004;
			statsBarY = window.innerHeight * 0.008;
			statsBarWidth = ((screen.width * 0.6) + (window.innerWidth * 0.4)) / 8;
			statsBarHeight = ((screen.height * 0.6) + (window.innerHeight * 0.4)) / 24;
		}

		function updateGameplayScreen() {
            //console.log(savedData.spellBooksArray, spellBooksArray);
			//console.log(mouseHeldItem[0]);
			//console.log(spellBooksArray);
			//console.log(spellBooksArray);

			// Calculate world coordinates
			mouseWorldX = (mouseMoveX / camera.zoom) + camera.x;
			mouseWorldY = (mouseMoveY / camera.zoom) + camera.y;

			// variable mostly used in the spell file but also in the followMouseMovement function here
			castMouseX = mouseWorldX - biome1.x;
			castMouseY = mouseWorldY - biome1.y;

			// Update camera to follow the player
			camera.follow(myGameCharacter, window.innerWidth, window.innerHeight);

			ctx.save();           // Save context state
			shake.apply(ctx);     // Apply screen shake
			camera.applyTransform(ctx);

			// Draw game objects
			biome1.draw(ctx);
			mobsArray.forEach(mob => {
				mob.draw(ctx);
				mob.newPos();
				mob.interact();
			});
			lootsArray.forEach(loot => loot.draw(ctx));
			spellsArray.forEach(spell => spell.update());
			myGameCharacter.draw(ctx);
			myGameCharacter.regenerateHealth();
			myGameCharacter.regenerateMana();
			updatePlayerPosition();

			// Reset transformations (important!!!)
			camera.resetTransform(ctx);
			shake.reset(ctx);     // Reset any screen shake transforms
			ctx.restore();        // Restore context state

			// logic part
			// --- Logic only every 50ms (20fps) ---
			//console.log(gameTime);
			//if (gameTime - lastLogicUpdate >= logicInterval) {
			// player and mob collision
			playerCrashWith(myGameCharacter, mobsArray);
			// player and loot collision
			playerCollideWithLoot(myGameCharacter, lootsArray);
			// player and spell collision
			playerCrashWithSpell(myGameCharacter, spellsArray);
			// mob to mob collision
			crashWith(mobsArray, mobsArray);
			// mob and spell collision
			crashWithSpell(spellsArray, mobsArray);

			//    lastLogicUpdate = gameTime;
			//}
			myGameCharacter.playerNewPos();
			myGameCharacter.movementX = 0;
			myGameCharacter.movementY = 0;
			myGameCharacter.moveAngle = 0;
			myGameCharacter.newSpeed = 0;
		}
		function updatePlayerPosition() {
			if (keyMovement) {
				if ((keys.KeyW || keys.ArrowUp) && (keys.KeyA || keys.ArrowLeft)) { // Up-Left
					myGameCharacter.angle = (1.75 * Math.PI);
					myGameCharacter.newSpeed = myGameCharacter.speed;
				} else if ((keys.KeyW || keys.ArrowUp) && (keys.KeyD || keys.ArrowRight)) { // Up-Right
					myGameCharacter.angle = (2.25 * Math.PI);
					myGameCharacter.newSpeed = myGameCharacter.speed;
				} else if ((keys.KeyS || keys.ArrowDown) && (keys.KeyA || keys.ArrowLeft)) { // Down-Left
					myGameCharacter.angle = (1.25 * Math.PI);
					myGameCharacter.newSpeed = myGameCharacter.speed;
				} else if ((keys.KeyS || keys.ArrowDown) && (keys.KeyD || keys.ArrowRight)) { // Down-Right
					myGameCharacter.angle = (0.75 * Math.PI);
					myGameCharacter.newSpeed = myGameCharacter.speed;
				} else if (keys.KeyW || keys.ArrowUp) { // Up
					myGameCharacter.angle = (2 * Math.PI);
					myGameCharacter.newSpeed = myGameCharacter.speed;
				} else if (keys.KeyS || keys.ArrowDown) { // Down
					myGameCharacter.angle = (1 * Math.PI);
					myGameCharacter.newSpeed = myGameCharacter.speed;
				} else if (keys.KeyA || keys.ArrowLeft) { // Left
					myGameCharacter.angle = (1.5 * Math.PI);
					myGameCharacter.newSpeed = myGameCharacter.speed;
				} else if (keys.KeyD || keys.ArrowRight) { // Right
					myGameCharacter.angle = (0.5 * Math.PI);
					myGameCharacter.newSpeed = myGameCharacter.speed;
				}
			}
			if (mouseMovement) {
				if (myGameCharacter.hasTarget && playerTargetX != null && playerTargetY != null) {
					// Calculate the difference in x and y between the current position and the target
					let dx = playerTargetX - myGameCharacter.x;
					let dy = playerTargetY - myGameCharacter.y;

					// Calculate the distance to the target
					let distance = Math.sqrt(dx * dx + dy * dy);

					myGameCharacter.newSpeed = myGameCharacter.speed;

					// Check if the character has reached the target
					if (distance <= myGameCharacter.newSpeed) {
						// Snap to target and stop moving
						myGameCharacter.x = playerTargetX;
						myGameCharacter.y = playerTargetY;
						playerTargetX = null;
						playerTargetY = null;
						myGameCharacter.hasTarget = false;
					} else {
						// Calculate the angle to the target
						myGameCharacter.angle = Math.atan2(dy, dx) - (1.5 * Math.PI);

						// Move toward the target
						myGameCharacter.x += myGameCharacter.newSpeed * Math.sin(myGameCharacter.angle);
						myGameCharacter.y -= myGameCharacter.newSpeed * Math.cos(myGameCharacter.angle);

						stayWithinMap(myGameCharacter, biome1);
					}
				}
			}
			if (followMouseMovement) {
				let dx = castMouseX - myGameCharacter.x;
				let dy = castMouseY - myGameCharacter.y;

				myGameCharacter.angle = Math.atan2(dy, dx) - (1.5 * Math.PI);

				if (keys.KeyW || keys.ArrowUp) {
					myGameCharacter.newSpeed = myGameCharacter.speed;

					myGameCharacter.x += myGameCharacter.newSpeed * Math.sin(myGameCharacter.angle);
					myGameCharacter.y -= myGameCharacter.newSpeed * Math.cos(myGameCharacter.angle);

                    stayWithinMap(myGameCharacter, biome1);
				}
			}
		}
		function shakeScreen(magnitude, duration) {
			shake.start(magnitude, duration);
		}
		function evaluatePlayerDamage(player, entity) {
			// The playerâ€™s attack rate is tied to the number of mobs â€” the more mobs around, the more often the player can â€œswing.â€
			// The system right now is more like a damage exchange trigger per mob, not a universal player attack cooldown.

			const now = performance.now();

			// give each mob its own damage cooldown
			if (!entity.lastDamageTime) {
				entity.lastDamageTime = 0;
			}

			// only allow damage every 250ms per mob (4x/sec)
			if (now - entity.lastDamageTime < 250) return;

			entity.lastDamageTime = now;

			// Apply damage
			let entityDamage = Math.max(0, entity.damage - player.defense);
			let playerDamage = Math.max(0, player.damage - entity.defense);
			entity.health = Math.max(0, entity.health - playerDamage);
			player.health = Math.max(0, player.health - entityDamage);

			// checks if damage is from a mob
			if (entity.codeClass == "mob" && entity.health <= 0) {
				player.experience += entity.experienceDrop;
				player.score += entity.experienceDrop
				levelUp();
				entity.spawn();
				entity.die();
			}
			// checks if damage is from a spell
			if (entity.codeClass == "spell" && entity.health <= 0) {
				player.speed = constantPlayerSpeed;
				entity.destroy();
			}

			// checks if opponent damage is equal to 5% of player health
			if (entityDamage >= player.health * 0.05) {
				shake.start(5, 200);
			}

			if (player.health <= 0) {
				playerDeath();
			}
		}
		function playerDeath() {
			myGameCharacter.state = "dead";

            // Move items from toBeCraftedMap to inventoryArray before saving and exiting
            for (const [key, item] of toBeCraftedMap.entries()) {
                inventoryArray.push(item);
            }
			toBeCraftedMap.clear();

            while (spellBooksArray.length > 0) {
                inventoryArray.push(spellBooksArray.shift());
            }

			StorageManager.saveAll();

			addText(textLibrary.gameOverText);
			addText(textLibrary.playerScoreText);

			buttonsMap.clear();
			addButton(buttonLibrary.exitButton, null);

            //inventoryArray = [];
			spellBooksArray = [];
			spellsArray = [];
			mobsArray = [];
			lootsArray = [];
			toBeCraftedMap.clear();

			for (let key in keys) {
				keys[key] = false;
			}
		}
		function levelUp() {
			if (myGameCharacter.experience >= myGameCharacter.maxExperience) {
				do {
					myGameCharacter.experience -= myGameCharacter.maxExperience;
					myGameCharacter.maxExperience += 100;
					myGameCharacter.level += 1;
					myGameCharacter.maxHealth += 5;
					myGameCharacter.maxMana += 1;
					myGameCharacter.manaRegen += 0.00025;
					myGameCharacter.summonLimit += 2.5;

					if (myGameCharacter.spellBookSlotsUnlocked < 5 && myGameCharacter.level >= 5) {
						myGameCharacter.spellBookSlotsUnlocked += 1;
						addButton(buttonLibrary.spellBookSlot5, 5);
						// add new spellBookSlot
					}
					if (myGameCharacter.spellBookSlotsUnlocked < 6 && myGameCharacter.level >= 15) {
						myGameCharacter.spellBookSlotsUnlocked += 1;
						addButton(buttonLibrary.spellBookSlot6, 6);
						// add new spellBookSlot
					}
					if (myGameCharacter.spellBookSlotsUnlocked < 7 && myGameCharacter.level >= 30) {
						myGameCharacter.spellBookSlotsUnlocked += 1;
						addButton(buttonLibrary.spellBookSlot7, 7);
						// add new spellBookSlot
					}
					if (myGameCharacter.spellBookSlotsUnlocked < 8 && myGameCharacter.level >= 45) {
						myGameCharacter.spellBookSlotsUnlocked += 1;
						addButton(buttonLibrary.spellBookSlot8, 8);
						// add new spellBookSlot
					}
					if (myGameCharacter.spellBookSlotsUnlocked < 9 && myGameCharacter.level >= 60) {
						myGameCharacter.spellBookSlotsUnlocked += 1;
						addButton(buttonLibrary.spellBookSlot9, 9);
						// add new spellBookSlot
					}
					//console.log(myGameCharacter.spellBookSlotsUnlocked);
				}
				while (myGameCharacter.experience >= myGameCharacter.maxExperience);
			}

			// Save the whole array properly
            savedData.maxHealth = myGameCharacter.maxHealth;
			savedData.maxMana = myGameCharacter.maxMana;
			// I think health regen doesn't increase. Right now I don't know what to do about that
            savedData.healthRegen = myGameCharacter.healthRegen;
			savedData.manaRegen = myGameCharacter.manaRegen;

			savedData.experience = myGameCharacter.experience;
            savedData.maxExperience = myGameCharacter.maxExperience;
			savedData.level = myGameCharacter.level;
			savedData.spellBookSlotsUnlocked = myGameCharacter.spellBookSlotsUnlocked;

			savedData.summonLimit = myGameCharacter.summonLimit;

            StorageManager.save("savedPlayerData", savedData);
		}
		// add loot to inventory for debugging purposes
		function addLootToInventory(loot, quantity) {
			let newLoot = new Loot(
				0, 0,
				loot.radius, loot.name, loot.spellBookName, loot.rarity,
				loot.dropChance, loot.appearance, loot.form, loot.type,
				loot.essenceName, loot.pagesToCraft, loot.essenceToCraft,
				loot.ignoreCollision, quantity, loot.stackLimit, loot.text
			);
			inventoryArray.push(newLoot);

			// Save the whole InventoryArray properly
            savedData.inventoryArray = inventoryArray;

            StorageManager.save("savedPlayerData", savedData);
		}

		function addButton(button, index) {
			let newButton = new Button(button.x, button.y, button.width, button.height, button.radii, button.color, button.name, button.group, button.classification, button.text, button.zIndex, index);
			buttonsMap.set(button.name, newButton);
		}
		function addSpellBook(spellBook, index, id = generateID()) {
			let newSpellBook = new SpellBook(
				spellBook.x,
				spellBook.y,
				index,
				spellBook.width,
				spellBook.height,
				spellBook.radii,
				"#000000",
				spellBook.appearance,
				spellBook.name,
				id,
				spellBook.spell,
				spellBook.spellCore,
				spellBook.level ?? 1,
                spellBook.levelStats,
				spellBook.cooldown,
				spellBook.text);

			if (index != null) {
				let slot = buttonsMap.get(`spellBookSlot${index}`);
				if (!slot.slotActive) {
					slot.slotActive = true;
					newSpellBook.onSlot = true;
					spellBooksArray.push(newSpellBook);

					// Save the whole array properly
                    savedData.spellBooksArray = spellBooksArray;

                    StorageManager.save("savedPlayerData", savedData);
				}
			} else {
				inventoryArray.push(newSpellBook);

				// Save the whole InventoryArray properly
                savedData.inventoryArray = inventoryArray;

                StorageManager.save("savedPlayerData", savedData);
			}
		}

        function levelUpSpellBook(spellBook) {
            //console.log("Leveling up:", spellBook.name, "â†’ Level", spellBook.level);

            const upgrades = spellBook.levelStats?.[spellBook.level];
            if (!upgrades) {
                //console.log("No upgrades for this level.");
                return spellBook;
            }

            if (upgrades.spell) {
				for (const [key, multiplier] of Object.entries(upgrades.spell)) {
					console.log(key);
                    if (key === "castQuantity") {
                        // special logic for spellQuantity
                        spellBook.spell.castQuantity += multiplier; // example: add instead of multiply
                        //console.log(`Increased spellQuantity by ${multiplier}`);
                    } else if (typeof spellBook.spell[key] === "number") {
                        spellBook.spell[key] *= multiplier;
                        //console.log(`Upgraded ${key}: Ã—${multiplier}`);
                    }
                }
            }

            return spellBook;
        }

        function setUpSpellBooks() {
            // Load saved data safely, with default structure
            const savedData = StorageManager.load("savedPlayerData", { spellBooksArray: [] });

            // Fallback if somehow missing or not an array
            const savedSpellBooks = Array.isArray(savedData.spellBooksArray) ? savedData.spellBooksArray : [];

            // Recreate spell books
            savedSpellBooks.forEach(data => {
                const baseTemplate = spellBookLibrary[data.name];

                if (!baseTemplate) {
                    console.warn(`Missing base template for: ${data.name}`);
                    return;
                }

                // Always refresh the latest static data
                data.levelStats = structuredClone(baseTemplate.levelStats);
                data.spellCore = { ...structuredClone(baseTemplate.spellCore), ...data.spellCore };

                // Start from base spell template (clean)
                let newSpell = structuredClone(baseTemplate.spell);

                // Reapply upgrades from level 2 â†’ current level
                for (let lvl = 2; lvl <= (data.level ?? 1); lvl++) {
                    const upgrades = data.levelStats[lvl];
                    if (!upgrades) continue;

                    if (upgrades.spell) {
                        for (const [key, multiplier] of Object.entries(upgrades.spell)) {
                            if (key === "castQuantity") {
                                // Special handling: additive rather than multiplicative
                                newSpell.castQuantity = (newSpell.castQuantity ?? 0) + multiplier;
                            } else if (typeof newSpell[key] === "number") {
                                newSpell[key] *= multiplier;
                            } else {
                                newSpell[key] = multiplier; // overwrite if non-number
                            }
                        }
                    }
                }

                // Update the spell with recalculated stats
                data.spell = newSpell;

                // Add spell book to the player inventory
                addSpellBook(data, data.index, data.uniqueID);
            });
        }

        function setUpInventory() {
            const savedData = StorageManager.load("savedPlayerData", { inventoryArray: [] });
            const inventory = Array.isArray(savedData.inventoryArray) ? savedData.inventoryArray : [];

            inventory.forEach(data => {
                if (data.codeClass === "loot") {
                    if (data.form === "page") {
                        // ðŸª„ Relink to latest spellBook template
                        if (typeof data.spellBookName === "string") {
                            // If somehow it was saved as a string name, resolve it
                            data.spellBookName = spellBookLibrary[data.spellBookName];
                        } else if (data.spellBookName?.name) {
                            // Otherwise, replace the old reference with the new template
                            const updatedSpellBook = spellBookLibrary[data.spellBookName.name];
                            if (updatedSpellBook) data.spellBookName = updatedSpellBook;
                            else console.warn(`Missing spellBook template for ${data.spellBookName.name}`);
                        }

                        addLootToInventory(data, data.quantity);
                    } else {
                        addLootToInventory(data, data.quantity);
                    }
                } else if (data.codeClass === "spellBook") {
                    addSpellBook(data, data.index, data.uniqueID);
                }
            });
        }

		function setUpPlayerName() {
			let nameInputButton = buttonsMap.get("nameInput");
			let nameInputButtonText = nameInputButton.text.trim();

			// If user input is empty, fallback to unnamed player
			if (!nameInputButtonText) {
				nameInputButtonText = "unnamed player";
			}

			// Update savedData with new or existing name
			savedData.name = nameInputButtonText;

			// Save to localStorage
         // localStorage.setItem("savedPlayerData", JSON.stringify(savedData));
            StorageManager.save("savedPlayerData", savedData);

			// Update the button text to reflect saved value
			nameInputButton.text = savedData.name;
		}

		function addText(text) {
			let newText = new Text(text.x, text.y, text.text, text.fontSize, text.fillColor, text.strokeColor, text.border, text.fontFamily, text.name, text.group, text.classification, text.zIndex, text.textInRect);
			textsMap.set(text.name, newText);
		}
		function dropLoot(loot) {
            let newLoot = new Loot(loot.x, loot.y, loot.radius, loot.name, loot.spellBookName, loot.rarity, loot.dropChance, loot.appearance, loot.form, loot.type, loot.essenceName, loot.pagesToCraft, loot.essenceToCraft, loot.ignoreCollision, loot.quantity, loot.stackLimit, loot.text)
			lootsArray.push(newLoot);
		}
		function castSpell(spell) {
			spellsArray.push(spell);
		}
		function spawnMobs() {
			for (let i = 0; i < starterMobsArray.length; i++) {
                for (let j = 0; j < (starterMobsArray[i].maxQuantity * mobDensity); j++) {
					let mobRandomX = ((biome1.x - camera.x) + (Math.floor((Math.random() * (starterMobsArray[i].setMaxX - starterMobsArray[i].setMinX + 1)) + starterMobsArray[i].setMinX))) + camera.x;
					let mobRandomY = ((biome1.y - camera.y) + (Math.floor((Math.random() * (starterMobsArray[i].setMaxY - starterMobsArray[i].setMinY + 1)) + starterMobsArray[i].setMinY))) + camera.y;
					let mobRandomRadiusXHealth = Math.floor((Math.random() * (starterMobsArray[i].setMaxHealth - starterMobsArray[i].setMinHealth + 1)) + starterMobsArray[i].setMinHealth);
					let newMob = new Mob(
						starterMobsArray[i].setMinX, starterMobsArray[i].setMaxX, starterMobsArray[i].setMinY, starterMobsArray[i].setMaxY,
						mobRandomX,
						mobRandomY,
						starterMobsArray[i].appearance,
						starterMobsArray[i].ignoreSpellCollision,
						starterMobsArray[i].ignoreMobCollision,
						mobRandomRadiusXHealth,
						starterMobsArray[i].defense,
						starterMobsArray[i].damage,
						mobRandomRadiusXHealth,
						starterMobsArray[i].radiusAdjust,
						starterMobsArray[i].movementSpeed,
						starterMobsArray[i].turnSpeed,
						starterMobsArray[i].FOVRadius,
						starterMobsArray[i].setMinHealth,
						starterMobsArray[i].setMaxHealth,
						starterMobsArray[i].name,
						starterMobsArray[i].side,
                        starterMobsArray[i].maxQuantity,
						starterMobsArray[i].type,
						starterMobsArray[i].ability,
						starterMobsArray[i].learnedSpells,
                        starterMobsArray[i].castQuantity,
						starterMobsArray[i].castDelay,
						starterMobsArray[i].intelligence,
						starterMobsArray[i].experienceDrop,
						starterMobsArray[i].lootDrop, 0, 0,
						starterMobsArray[i].respawnTime);
					mobsArray.push(newMob);
				}
			}
		}
        function crashWith(mob1Array, mob2Array) {
            mob1Array.forEach(mob1 => {
                mob2Array.forEach(mob2 => {
                    let dx = mob2.x - mob1.x;
                    let dy = mob2.y - mob1.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);
                    const radii = mob1.radius + mob2.radius;

					if (distance < radii) {
						// Handle zero-distance (stacked mobs)
						if (distance === 0) {
							const angle = Math.random() * 2 * Math.PI;
							dx = Math.cos(angle);
							dy = Math.sin(angle);
							distance = 1; // prevent division by zero
						}

						const overlap = radii - distance;

						// Weight-based knockback (larger mob moves less)
						const totalRadius = mob1.radius + mob2.radius;
						const weight1 = mob2.radius / totalRadius; // how much mob1 moves
						const weight2 = mob1.radius / totalRadius; // how much mob2 moves

						if (!mob1.ignoreMobCollision) {
							mob1.x -= (dx / distance) * overlap * weight1;
							mob1.y -= (dy / distance) * overlap * weight1;
						}

						if (!mob2.ignoreMobCollision) {
							mob2.x += (dx / distance) * overlap * weight2;
							mob2.y += (dy / distance) * overlap * weight2;
						}
					}
					//stayWithinMap(mob1, biome1);
                    //stayWithinMap(mob2, biome1);
                });
            });
        }
		function playerCollideWithLoot(mob, lootsArray) {
			lootsArray.forEach((loot, index) => {
				let dx = loot.x - mob.x;
				let dy = loot.y - mob.y;
				let distance = Math.sqrt(dx * dx + dy * dy);
				let radii = mob.radius + loot.radius + mob.pickUpRange;

				if (distance < radii) {
					// Collect loot
					// check if the loot should stack
					/* future project
					let allStackableLootArray = inventoryArray.filter(element => element.name === loot.name && element.stackLimit > element.quantity);
					console.log(allStackableLootArray);
					if (allStackableLootArray.length > 1) {
						for (let i = 0; i < allStackableLootArray.length; i++) {
							allStackableLootArray[i].quantity + allStackableLootArray[i].quantity;
						}
					}
					*/
					if (loot.name == "manaOrb") {
						let manaFromOrb = 1;
						if (myGameCharacter.mana + manaFromOrb <= myGameCharacter.maxMana) {
							myGameCharacter.mana += manaFromOrb;
							//console.log("hi");
						}
					} else if (loot.form != "effect") {
                        let stackableLootIndex = inventoryArray.findIndex(element => element.name === loot.name && element.stackLimit > element.quantity);
                        if (stackableLootIndex !== -1 && inventoryArray[stackableLootIndex].quantity + loot.quantity <= inventoryArray[stackableLootIndex].stackLimit) {
                            inventoryArray[stackableLootIndex].quantity += loot.quantity;
						} else {
							inventoryArray.push(loot);
						}

						// Save the whole InventoryArray properly
                        savedData.inventoryArray = inventoryArray;

                        StorageManager.save("savedPlayerData", savedData);
					}
					lootsArray.splice(index, 1); // Remove loot from the array
				}
			});
		}
		function playerCrashWith(player, mobArray) {
			mobArray.forEach(mob => {
				let dx = mob.x - player.x;
				let dy = mob.y - player.y;
				let distance = Math.sqrt(dx * dx + dy * dy);
				let radii = player.radius + mob.radius;
				if (distance < radii) {
					// Apply knockback
					const angle = Math.atan2(dy, dx);
					const knockbackDistance = (radii - distance) * 1; // Prevent overlap
					if (!player.ignoreMobCollision) {
						player.x -= Math.cos(angle) * knockbackDistance;
						player.y -= Math.sin(angle) * knockbackDistance;
						
                        //stayWithinMap(player, biome1);
					}
					if (!mob.ignoreMobCollision) {
						mob.x += Math.cos(angle) * knockbackDistance;
						mob.y += Math.sin(angle) * knockbackDistance;

                        //stayWithinMap(mob, biome1);
					}
					evaluatePlayerDamage(player, mob);
				}
			});
		}
		function playerCrashWithSpell(player, spellsArray) {
			spellsArray.forEach(spell => {
				if (spell.art != "books") {
					if (spell.side != player.side) {
						if (spell.shape == "circle") {
							let dx = spell.x - player.x;
							let dy = spell.y - player.y;
							let distance = Math.sqrt(dx * dx + dy * dy);
							let radii = spell.radius + player.radius;
							if (distance < radii) {
								simulateCollision();
							}
						}
						if (spell.shape == "line") {
							// Calculate the closest point on the line segment to the circle center
							const lineStart = { x: spell.x, y: spell.y };
							const lineEnd = { x: spell.x2, y: spell.y2 };
							const circleCenter = { x: player.x, y: player.y };

							// Vector from line start to circle center
							const lineToCircle = {
								x: circleCenter.x - lineStart.x,
								y: circleCenter.y - lineStart.y
							};

							// Line segment vector
							const lineVector = {
								x: lineEnd.x - lineStart.x,
								y: lineEnd.y - lineStart.y
							};

							// Calculate projection of lineToCircle onto lineVector
							const lineLengthSquared = lineVector.x * lineVector.x + lineVector.y * lineVector.y;
							let t = ((lineToCircle.x * lineVector.x) + (lineToCircle.y * lineVector.y)) / lineLengthSquared;

							// Clamp t to stay within the segment bounds
							t = Math.max(0, Math.min(1, t));

							// Find the closest point on the line segment
							const closestPoint = {
								x: lineStart.x + t * lineVector.x,
								y: lineStart.y + t * lineVector.y
							};

							// Distance from circle center to closest point
							const dx = closestPoint.x - circleCenter.x;
							const dy = closestPoint.y - circleCenter.y;
							const distance = Math.sqrt(dx * dx + dy * dy);

							if (distance < player.radius) {
								evaluatePlayerDamage(player, spell);
							}
						}
						function simulateCollision() {
							// Apply knockback to both spell and player

							const dx = player.x - spell.x;
							const dy = player.y - spell.y;
							const angle = Math.atan2(dy, dx);

							if (!spell.ignoreMobCollision) {
								spell.x -= Math.cos(angle) * spellKnockbackDistance;
								spell.y -= Math.sin(angle) * spellKnockbackDistance;
							}
							if (!player.ignoreSpellCollision) {
								player.x += Math.cos(angle) * spellKnockbackDistance;
								player.y += Math.sin(angle) * spellKnockbackDistance;

                                //stayWithinMap(player, biome1);
							}
							evaluatePlayerDamage(player, spell);
						}
					}
				}
			});
		}
		function crashWithSpell(spellsArray, mobArray) {
			spellsArray.forEach(spell => {
				if (spell.art != "books") {
					for (let mobIndex = 0; mobIndex < mobArray.length; mobIndex++) {
						let mob = mobArray[mobIndex];
						if (spell.side != mob.side) {
							if (spell.shape == "circle") {
								let dx = spell.x - mob.x;
								let dy = spell.y - mob.y;
								let distance = Math.sqrt(dx * dx + dy * dy);
								let radii = spell.radius + mob.radius;
								if (distance < radii) {
									simulateCollision();
								}
							}
							if (spell.shape == "line") {
								// Calculate the closest point on the line segment to the circle center
								const lineStart = { x: spell.x, y: spell.y };
								const lineEnd = { x: spell.x2, y: spell.y2 };
								const circleCenter = { x: mob.x, y: mob.y };

								// Vector from line start to circle center
								const lineToCircle = {
									x: circleCenter.x - lineStart.x,
									y: circleCenter.y - lineStart.y
								};

								// Line segment vector
								const lineVector = {
									x: lineEnd.x - lineStart.x,
									y: lineEnd.y - lineStart.y
								};

								// Calculate projection of lineToCircle onto lineVector
								const lineLengthSquared = lineVector.x * lineVector.x + lineVector.y * lineVector.y;
								let t = ((lineToCircle.x * lineVector.x) + (lineToCircle.y * lineVector.y)) / lineLengthSquared;

								// Clamp t to stay within the segment bounds
								t = Math.max(0, Math.min(1, t));

								// Find the closest point on the line segment
								const closestPoint = {
									x: lineStart.x + t * lineVector.x,
									y: lineStart.y + t * lineVector.y
								};

								// Distance from circle center to closest point
								const dx = closestPoint.x - circleCenter.x;
								const dy = closestPoint.y - circleCenter.y;
								const distance = Math.sqrt(dx * dx + dy * dy);

								if (distance < mob.radius) {
									simulateCollision();
								}
							}
							function simulateCollision() {

								// Apply damage to the mob
								let calculatedSpellDamage = spell.damage - mob.defense;
								if (calculatedSpellDamage <= 0) {
									calculatedSpellDamage = 0;
								}
								mob.health -= calculatedSpellDamage;

								let calculatedMobDamage = mob.damage - spell.defense;
								if (calculatedMobDamage <= 0) {
									calculatedMobDamage = 0;
								}
								// Apply damage to the spell
								spell.health -= calculatedMobDamage;

								// Check if the mob should die and be removed
								if (mob.health <= 0) {
									myGameCharacter.experience += mob.experienceDrop;
									myGameCharacter.score += mob.experienceDrop;
									levelUp();
									mob.spawn();
									mob.die();
								}
								// Remove the spell only if its health is <= 0 after damaging all mobs
								if (spell.health <= 0) {
									//temporary solution to bug number 3. make sure to finalize this
									myGameCharacter.speed = constantPlayerSpeed;
									spell.destroy();
								}
								// Apply knockback to both spell and mob
								if (spell.shape == "circle") {
									const dx = mob.x - spell.x;
									const dy = mob.y - spell.y;
									const angle = Math.atan2(dy, dx);

									if (!spell.ignoreMobCollision) {
										spell.x -= Math.cos(angle) * spellKnockbackDistance;
										spell.y -= Math.sin(angle) * spellKnockbackDistance;
									}
									if (!mob.ignoreSpellCollision) {
										mob.x += Math.cos(angle) * spellKnockbackDistance;
										mob.y += Math.sin(angle) * spellKnockbackDistance;
                                        //stayWithinMap(mob, biome1);
									}
								}
							}
						}
					}
				}
			});
		}
		/*
		tasks:
		8). add upgrades points. you can earn ugrade points when leveling up
		14). add spells that can be casted multiple times in a row but they rely heavily on mana (they're a different type from spellBooks)
		15). make the spellBooks run on cooldown instead of mana
		16). then there will be natural spells that run on purely mana
		1000). add a place where npcs will go to when their kingdom is invaded
		1001). most people arent allowed to go to that place because that place is only for emergencies and they cant risk it getting invaded
		1002). make npcs killable (someone rich and willing needs to resurect them) (there will be a sign that says theyve been killed or something)
		1003). squads/teams will be a thing where friends can play together
		1004). there should be a local gamemode so people can still have fun
		1005). add some ads
		1006). ranks should be a thing
		1007). a spellBook that progressively gets stronger the more mobs you kill

		game issues to fix:
		bug 2 is fixed. but im not removing it because it has existed for years and only got removed today 17/10/2024 3:37 AM
		2). the spell book issue happens when a spell book hits 2 basic mob at the same time because the crashWith function is called twice and deletes 2 spellbooks.
		3). on the spell aoe ability, the player speed reverting back to normal value doesn't work when the spell
		finishes its job because it gets destroyed by a mob before it can even apply the code line.
		this also applies to the beams, we just didn't notice.
		4). spell line to circle knockback doesn't work properly. it pulls the circle instead of pushing away.
		*/
	</script>
</body>
</html>
